#!/bin/bash
# INDENTING (emacs/vi): -*- mode:bash; tab-width:2; c-basic-offset:2; intent-tabs-mode:nil; -*- ex: set tabstop=2 expandtab smartindent shiftwidth=2:


## Usage
[ $# -lt 1 -o "${1##*-}" == 'help' ] && cat << EOF && exit 1
USAGE: ${0##*/} <action> [<parameter> ...]

SYNOPSIS:
  Perform the requested action in the configuration repository.

ACTIONS:
  list [<flag>|@FLAGS]
    List the content of the configuration repository (matching the given
    optional flag or GIT status)

  a2ps <output-file>
    Create a Postscript document with all files in the configuration repository

  new [--batch] [--symbolic|--copy] <file> [<original-file>]
    Add the given file to/from the configuration repository
    (using symlink or copy operation instead of hardlink)

  copy [--batch] [--symbolic|--copy] [--force] <file> <source>
  rm [--batch] [--force] <file>
    Copy/remove the given file from the given source, provided it has not been
    edited (unless '--force' is specified)
    (using symlink or copy operation instead of hardlink)

  edit <file>
    Edit the given file (after adding it to the configuration repository)

  perm <file> [<mode> [<ownership>]]
    Show/change the permissions of the given file

  orig <file>
    Show the original version of the given file

  diff <file>
    Show the differences between the given file and its previous GIT version

  delta <file> [<comment-prefix>='#']
    Show the differences between the given file and its original version,
    with all comments stripped out

  flag|unflag <file> <flag>
  flagged <file> [<flag>]
    Set|show/check|remove the specified flag for the given file

  verify
    Verify the consistency between the configuration repository and the actual
    files

  pkglist
    Update the list of installed packages

  git <git-command> [<git-parameter> ...]
    Perform the corresponding command within the GIT repository
    (see 'git help ...' for available commands/parameters)
EOF


## Arguments
GCFG_ACTION="${1}" && shift


## Functions
source gcfg.functions
_gcfg_check || exit $?


## Action
case "${GCFG_ACTION}" in

  'list')
    # ... arguments
    GCFG_FLAG=; [ $# -ge 1 ] && GCFG_FLAG="${1}" && shift
    [ "${GCFG_FLAG:0:5}" == '@GIT:' ] && GCFG_FLAG="${GCFG_FLAG:0:7}"
    # ... list content of GIT repository
    _gcfg_pushd || exit $?
    join -t'|' -a 1 <(find . -type f -not -path './.git/*' | sed 's/^\.//' | sort) <(git status --porcelain | sed 's/^\(..\) \(.*\)$/\/\2|@GIT:\1/;s/ /_/g' | sort -t'|' -k1,1) | sed 's/^\([^|]*\)$/\1|@GIT:__/' | while read GIT_FILE; do
      gitstat="${GIT_FILE#*|}"
      GCFG_FILE="${GIT_FILE%|*}"
      if [ "${GCFG_FLAG}" == '@FLAGS' ]; then
        echo "${GCFG_FILE}|$(ls -1 "$(_gcfg_path_flag "${GCFG_FILE}")"\{*\} 2>/dev/null | sed 's/.*{\([^}]*\)}$/\1/' | sort | tr '\n' ',')${gitstat}"
        continue
      elif [ "${GCFG_FLAG:0:5}" == '@GIT:' ]; then
        [ "${gitstat:5:2}" == "${GCFG_FLAG:5:2}" ] || continue 
      elif [ -n "${GCFG_FLAG}" ]; then
        gcfg flagged "${GCFG_FILE}" "${GCFG_FLAG}" || continue
      fi
      echo "${GCFG_FILE}"
    done
    _gcfg_popd || exit $?
    ;;

  'a2ps')
    # ... check
    [ -z "$(which a2ps)" ] && _gcfg_error "${GCFG_ACTION}" 'Missing required utility (a2ps)' && exit 1
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <output-file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    GCFG_FILE_DIR="$(dirname "${GCFG_FILE}")"
    [ ! -w "${GCFG_FILE_DIR}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/unwritable directory' "${GCFG_FILE_DIR}" && exit 1
    if [ -e "${GCFG_FILE}" ]; then
      _gcfg_confirm "${GCFG_ACTION}" 'Configuration document already exists; overwrite ?'
      [ "$(_gcfg_answer 'y/n')" == 'n' ] && exit 0
      [ ! -w "${GCFG_FILE}" ] && _gcfg_error "${GCFG_ACTION}" 'Unwritable file' "${GCFG_FILE}" && exit 1
    fi
    # ... compile postcript document
    _gcfg_pushd || exit $?
    a2ps --medium=A4 --portrait --columns=1 --borders=on --no-header --toc --left-title='$f' --right-title='$p./$p#' --left-footer='%m - %D{%d.%m.%Y}' --right-footer='%p./%p#' --chars-per-line=100 --file-align=sheet --encoding=ISO-8859-1 --output="${GCFG_FILE}" $(find . -not -path './.git/*' -type f | xargs file | awk -F':' '{ if( $2 ~ /text/ ) print $1 }' | sed 's/^\.*//')
    chmod 600 "${GCFG_FILE}"
    [ $? -ne 0 ] && _gcfg_warning "${GCFG_ACTION}" 'Failed to change file access mode' "${GCFG_FILE}"
    _gcfg_popd || exit $?
    ;;

  'new')
    # ... arguments
    GCFG_BATCH=; GCFG_LINK='hard'
    while [ "${1:0:2}" == '--' ]; do
      case "${1}" in
        '--batch') GCFG_BATCH='y';;
        '--hard') GCFG_LINK='hard';;
        '--symbolic') GCFG_LINK='symbolic';;
        '--copy') GCFG_LINK='copy';;
        *) _gcfg_warning "${GCFG_ACTION}" 'Unrecognized option' "${1}";;
      esac
      shift
    done
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    GCFG_FILE_ORIG_SRC=; [ $# -ge 1 ] && GCFG_FILE_ORIG_SRC="${1}" && shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    [ -e "${GCFG_FILE}" -a ! -h "${GCFG_FILE}" -a ! -f "${GCFG_FILE}" ] && _gcfg_error "${GCFG_ACTION}" 'Invalid file type' "${GCFG_FILE}" && exit 1
    if [ -n "${GCFG_FILE_ORIG_SRC}" ]; then
      [ ! -r "${GCFG_FILE_ORIG_SRC}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/unreadable file' "${GCFG_FILE_ORIG_SRC}" && exit 1
    fi
    GCFG_FILE_GIT="$(_gcfg_path_git "${GCFG_FILE}")" || exit $?
    [ -e "${GCFG_FILE_GIT}" ] && exit 0
    GCFG_FILE_DIR="$(dirname "${GCFG_FILE}")"
    [ ! -w "${GCFG_FILE_DIR}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/unwritable directory' "${GCFG_FILE_DIR}" && exit 1
    GCFG_FILE_GIT_DIR="$(dirname "${GCFG_FILE_GIT}")"
    [ ! -e "${GCFG_FILE_GIT_DIR}" ] && mkdir -p "${GCFG_FILE_GIT_DIR}"
    [ ! -d "${GCFG_FILE_GIT_DIR}" ] && _gcfg_error "${GCFG_ACTION}" 'Failed to create directory' "${GCFG_FILE_GIT_DIR}" && exit 1
    if [ -e "${GCFG_FILE}" ]; then
      [ ! -f "${GCFG_FILE}" ] && _gcfg_error "${GCFG_ACTION}" 'Not a regular file' "${GCFG_FILE}" && exit 1
      [ ! -r "${GCFG_FILE}" ] && _gcfg_error "${GCFG_ACTION}" 'Unreadable file' "${GCFG_FILE}" && exit 1
      # ... backup original file
      if [ -z "${GCFG_FILE_ORIG_SRC}" -a -z "${GCFG_BATCH}" ]; then
        _gcfg_confirm "${GCFG_ACTION}" 'Keep a backup of the original file ?'
        answer="$(_gcfg_answer 'y/n')"
        [ "${answer}" == 'y' ] && GCFG_FILE_ORIG_SRC="${GCFG_FILE}"
      fi
    else
      # ... create empty file
      touch "${GCFG_FILE}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to create file' "${GCFG_FILE}" && exit 1
      _gcfg_warning "${GCFG_ACTION}" "New file created; check its permissions ('${0##*/} perm ...')" "${GCFG_FILE}"
    fi
    # ... backup original file
    if [ -n "${GCFG_FILE_ORIG_SRC}" ]; then
      GCFG_FILE_ORIG="$(_gcfg_path_original "${GCFG_FILE}")" || exit $?
      GCFG_FILE_ORIG_DIR="$(dirname "${GCFG_FILE_ORIG}")"
      [ ! -e "${GCFG_FILE_ORIG_DIR}" ] && mkdir -p "${GCFG_FILE_ORIG_DIR}"
      [ ! -d "${GCFG_FILE_ORIG_DIR}" ] && _gcfg_error "${GCFG_ACTION}" 'Failed to create directory' "${GCFG_FILE_ORIG_DIR}" && exit 1
      cp -p "${GCFG_FILE_ORIG_SRC}" "${GCFG_FILE_ORIG}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to copy file' "${GCFG_FILE_ORIG_SRC} -> ${GCFG_FILE_ORIG}" && exit 1
    fi
    # ... move file to configuration repository
    mv "${GCFG_FILE}" "${GCFG_FILE_GIT}"
    [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to move file' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && exit 1
    if [ "${GCFG_LINK}" == 'copy' ]; then
      # ... copy back
      cp -p "${GCFG_FILE_GIT}" "${GCFG_FILE}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to copy file' "${GCFG_FILE_GIT} -> ${GCFG_FILE}" && exit 1
    elif [ "${GCFG_LINK}" == 'symbolic' ]; then
      # ... symlink back
      ln -s "${GCFG_FILE_GIT}" "${GCFG_FILE}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to symlink file' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && exit 1
    else
      # ... hardlink back
      ln "${GCFG_FILE_GIT}" "${GCFG_FILE}"
      if [ $? -ne 0 ]; then
        _gcfg_warning "${GCFG_ACTION}" 'Failed to hardlink file; Copying instead' "${GCFG_FILE} -> ${GCFG_FILE_GIT}"
        cp -p "${GCFG_FILE_GIT}" "${GCFG_FILE}"
        [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to copy file' "${GCFG_FILE_GIT} -> ${GCFG_FILE}" && exit 1
      fi
    fi
    # ... add file to GIT
    late_exit=0
    _gcfg_pushd || exit $?
    git add "${GCFG_FILE##/}"
    [ $? -ne 0 ] && late_exit=$? && _gcfg_error "${GCFG_ACTION}" 'Failed to add file to GIT' "${GCFG_FILE_GIT}"
    _gcfg_popd || exit $?
    [ ${late_exit} -ne 0 ] && exit ${late_exit}
    _gcfg_info "${GCFG_ACTION}" 'File successfully added to configuration repository' "${GCFG_FILE}"
    ;;

  'rm')
    # ... arguments
    GCFG_BATCH=; GCFG_FORCE=
    while [ "${1:0:2}" == '--' ]; do
      case "${1}" in
        '--batch') GCFG_BATCH='y';;
        '--force') GCFG_FORCE='y';;
        *) _gcfg_warning "${GCFG_ACTION}" 'Unrecognized option' "${1}";;
      esac
      shift
    done
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    GCFG_FILE_GIT="$(_gcfg_path_git "${GCFG_FILE}")" || exit $?
    GCFG_FILE_ORIG="$(_gcfg_path_original "${GCFG_FILE}")" || exit $?
    GCFG_FILE_FLAG="$(_gcfg_path_flag "${GCFG_FILE}")" || exit $?
    # ... confirmation
    if [ -n "${GCFG_BATCH}" ]; then
      [ ! -e "${GCFG_FILE_GIT}" ] && exit 0
      if gcfg flagged "${GCFG_FILE}" '@EDITED'; then
        if [ -z "${GCFG_FORCE}" ]; then
          _gcfg_warning "${GCFG_ACTION}" 'File has been modified; skipping...' "${GCFG_FILE}"
          exit 0
        fi
      fi
    else
      [ ! -e "${GCFG_FILE_GIT}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/non-existant file' "${GCFG_FILE_GIT}" && exit 1
      _gcfg_confirm "${GCFG_ACTION}" 'Are you sure you want to remove from the configuration repository ?'
      [ "$(_gcfg_answer 'y/n')" == 'n' ] && exit 0
    fi
    # ... remove file from GIT
    late_exit=0
    _gcfg_pushd || exit $?
    git rm --force "${GCFG_FILE##/}" >/dev/null
    [ $? -ne 0 ] && late_exit=$? && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file from GIT' "${GCFG_FILE_GIT}"
    _gcfg_popd || exit $?
    [ ${late_exit} -ne 0 ] && exit ${late_exit}
    # ... remove file flags
    for flag in "${GCFG_FILE_FLAG}"\{*\}; do
      rm -f "${flag}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${flag}" && exit 1
    done
    # ... remove actual file
    if [ -h "${GCFG_FILE}" -o -e "${GCFG_FILE}" ]; then
      rm -f "${GCFG_FILE}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${GCFG_FILE}" && exit 1
    fi
    # ... restore orginal backup file
    if [ -e "${GCFG_FILE_ORIG}" ]; then
      mv "${GCFG_FILE_ORIG}" "${GCFG_FILE}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to move file' "${GCFG_FILE_ORIG} -> ${GCFG_FILE}" && exit 1
      _gcfg_info "${GCFG_ACTION}" 'Original file successfully restored' "${GCFG_FILE}"
    else
      _gcfg_info "${GCFG_ACTION}" 'File successfully removed' "${GCFG_FILE}"
    fi
    # ... cleanup directories
    _gcfg_rmdir "$(dirname "${GCFG_FILE}")"
    ;;

  'copy')
    # ... arguments
    GCFG_BATCH=; GCFG_LINK='hard'; GCFG_FORCE=
    while [ "${1:0:2}" == '--' ]; do
      case "${1}" in
        '--batch') GCFG_BATCH='y';;
        '--hard') GCFG_LINK='hard';;
        '--symbolic') GCFG_LINK='symbolic';;
        '--copy') GCFG_LINK='copy';;
        '--force') GCFG_FORCE='y';;
        *) _gcfg_warning "${GCFG_ACTION}" 'Unrecognized option' "${1}";;
      esac
      shift
    done
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <source> parameter' && exit 1
    GCFG_SOURCE="${1}"; shift
    [ ! -f "${GCFG_SOURCE}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/invalid file' "${GCFG_SOURCE}" && exit 1
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    [ -e "${GCFG_FILE}" -a ! -h "${GCFG_FILE}" -a ! -f "${GCFG_FILE}" ] && _gcfg_error "${GCFG_ACTION}" 'Invalid file type' "${GCFG_FILE}" && exit 1
    GCFG_FILE_GIT="$(_gcfg_path_git "${GCFG_FILE}")" || exit $?
    # ... install
    if [ -e "${GCFG_FILE}" ]; then
      if [ -n "${GCFG_BATCH}" ]; then
        gcfg new --batch --${GCFG_LINK} "${GCFG_FILE}" "${GCFG_FILE}" || exit $?
      else
        gcfg new --${GCFG_LINK} "${GCFG_FILE}" || exit $?
      fi
      if gcfg flagged "${GCFG_FILE}" '@EDITED'; then
        if [ -z "${GCFG_FORCE}" ]; then
          _gcfg_warning "${GCFG_ACTION}" 'File already exists and has been modified; skipping...' "${GCFG_SOURCE} x> ${GCFG_FILE}"
        else
          gcfg unflag "${GCFG_FILE}" '@EDITED' || exit $?
        fi
      else
        cp -p "${GCFG_SOURCE}" "${GCFG_FILE}"
        [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to copy file' "${GCFG_SOURCE} -> ${GCFG_FILE}" && exit 1
        _gcfg_info "${GCFG_ACTION}" 'File copied successfully' "${GCFG_SOURCE} -> ${GCFG_FILE}"
      fi
    else
      cp -p "${GCFG_SOURCE}" "${GCFG_FILE}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to copy file' "${GCFG_SOURCE} -> ${GCFG_FILE}" && exit 1
      _gcfg_info "${GCFG_ACTION}" 'File copied successfully' "${GCFG_SOURCE} -> ${GCFG_FILE}"
      gcfg new --batch --${GCFG_LINK} "${GCFG_FILE}" || exit $?
    fi
    ;;

  'edit')
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    [ -e "${GCFG_FILE}" -a ! -h "${GCFG_FILE}" -a ! -f "${GCFG_FILE}" ] && _gcfg_error "${GCFG_ACTION}" 'Invalid file type' "${GCFG_FILE}" && exit 1
    GCFG_FILE_GIT="$(_gcfg_path_git "${GCFG_FILE}")" || exit $?
    # ... check repository
    if [ ! -e "${GCFG_FILE_GIT}" ]; then
      _gcfg_confirm "${GCFG_ACTION}" 'File does not exist in the configuration repository; add ?'
      if [ "$(_gcfg_answer 'y/n')" == 'y' ]; then
        gcfg new "${GCFG_FILE}" || exit $?
      fi
    fi
    # ... edit
    GCFG_CKSUM="$(cksum "${GCFG_FILE}" 2>/dev/null)"
    [ -z "${EDITOR}" ] && EDITOR=vim
    "${EDITOR}" "${GCFG_FILE}"
    # ... flag
    if [ -e "${GCFG_FILE_GIT}" -a "$(cksum "${GCFG_FILE}" 2>/dev/null)" != "${GCFG_CKSUM}" ]; then
      gcfg flag "${GCFG_FILE}" '@EDITED' || exit $?
    fi
    ;;

  'perm')
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    GCFG_CHMOD=; [ $# -ge 1 ] && GCFG_CHMOD="${1}" && shift
    GCFG_CHOWN=; [ $# -ge 1 ] && GCFG_CHOWN="${1}" && shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    GCFG_FILE_GIT="$(_gcfg_path_git "${GCFG_FILE}")" || exit $?
    [ ! -e "${GCFG_FILE_GIT}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/non-existent file' "${GCFG_FILE_GIT}" && exit 1
    # ... set permissions
    if [ -n "${GCFG_CHMOD}" ]; then
      chmod ${GCFG_CHMOD} "${GCFG_FILE_GIT}"
      [ $? -ne 0 ] && _gcfg_warning "${GCFG_ACTION}" 'Failed to change file access mode' "${GCFG_FILE_GIT}"
    fi
    if [ -n "${GCFG_CHOWN}" ]; then
      chown ${GCFG_CHOWN} "${GCFG_FILE_GIT}"
      [ $? -ne 0 ] && _gcfg_warning "${GCFG_ACTION}" 'Failed to change file ownership' "${GCFG_FILE_GIT}"
    fi
    ls -l "${GCFG_FILE_GIT}"
    ;;

  'orig')
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    GCFG_FILE_ORIG="$(_gcfg_path_original "${GCFG_FILE}")" || exit $?
    [ ! -r "${GCFG_FILE_ORIG}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/unreadable file' "${GCFG_FILE_ORIG}" && exit 1
    # ... show file
    cat "${GCFG_FILE_ORIG}"
    ;;

  'diff')
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    [ ! -r "${GCFG_FILE}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/unreadable file' "${GCFG_FILE}" && exit 1
    GCFG_FILE_GIT="$(_gcfg_path_git "${GCFG_FILE}")" || exit $?
    [ ! -r "${GCFG_FILE_GIT}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/unreadable file' "${GCFG_FILE_GIT}" && exit 1
    # ... GIT command
    _gcfg_pushd || exit $?
    git ${GCFG_ACTION} $* -- ${GCFG_FILE##/}
    _gcfg_popd || exit $?
    ;;

  'delta')
    # ... check
    [ -z "$(which diff)" ] && _gcfg_error "${GCFG_ACTION}" 'Missing required utility (diff)' && exit 1
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    COMMENT_PREFIX='#'; [ $# -ge 1 ] && COMMENT_PREFIX="${1}" && shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    [ ! -r "${GCFG_FILE}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/unreadable file' "${GCFG_FILE}" && exit 1
    GCFG_FILE_ORIG="$(_gcfg_path_original "${GCFG_FILE}")" || exit $?
    [ ! -r "${GCFG_FILE_ORIG}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/unreadable file' "${GCFG_FILE_ORIG}" && exit 1
    # ... show differences
    if [ -t 1 ]; then
      diff -uN <(egrep -v "^[[:space:]]*(${COMMENT_PREFIX}${COMMENT_PREFIX:+|}$)" "${GCFG_FILE_ORIG}") <(egrep -v "^[[:space:]]*(${COMMENT_PREFIX}${COMMENT_PREFIX:+|}$)" "${GCFG_FILE}") | sed "/^\(---\|+++\)/d;s/^+/$(printf '\e[32m')+/;s/^-/$(printf '\e[31m')-/;s/^@/$(printf '\e[36m')@/;s/$/$(printf '\e[0m')/"
    else
      diff -uN <(egrep -v "^[[:space:]]*(${COMMENT_PREFIX}${COMMENT_PREFIX:+|}$)" "${GCFG_FILE_ORIG}") <(egrep -v "^[[:space:]]*(${COMMENT_PREFIX}${COMMENT_PREFIX:+|}$)" "${GCFG_FILE}")
    fi
    ;;

  'flag')
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <flag> parameter' && exit 1
    GCFG_FLAG="${1}"; shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    GCFG_FILE_GIT="$(_gcfg_path_git "${GCFG_FILE}")" || exit $?
    [ ! -e "${GCFG_FILE_GIT}" ] && _gcfg_error "${GCFG_ACTION}" 'Missing/non-existant file' "${GCFG_FILE_GIT}" && exit 1
    GCFG_FILE_FLAG="$(_gcfg_path_flag "${GCFG_FILE}" "${GCFG_FLAG}")" || exit $?
    GCFG_FILE_FLAG_DIR="$(dirname "${GCFG_FILE_FLAG}")"
    # ... create flag
    [ ! -e "${GCFG_FILE_FLAG_DIR}" ] && mkdir -p "${GCFG_FILE_FLAG_DIR}"
    touch "${GCFG_FILE_FLAG}"
    [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to create file' "${GCFG_FILE_FLAG}" && exit 1
    ;;

  'flagged')
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    GCFG_FLAG=; [ $# -ge 1 ] && GCFG_FLAG="${1}" && shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    GCFG_FILE_FLAG="$(_gcfg_path_flag "${GCFG_FILE}" "${GCFG_FLAG}")" || exit $?
    # ... check flag
    if [ -n "${GCFG_FLAG}" ]; then
      [ ! -e "${GCFG_FILE_FLAG}" ] && exit 1 || exit 0
    fi
    ls -1 "${GCFG_FILE_FLAG}"\{*\} 2>/dev/null | sed 's/.*{\([^}]*\)}$/\1/' | sort
    exit ${PIPESTATUS[0]}
    ;;

  'unflag')
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <file> parameter' && exit 1
    GCFG_FILE="${1}"; shift
    GCFG_FLAG=; [ $# -ge 1 ] && GCFG_FLAG="${1}" && shift
    # ... paths
    GCFG_FILE="$(_gcfg_path_canonical "${GCFG_FILE}")" || exit $?
    GCFG_FILE_FLAG="$(_gcfg_path_flag "${GCFG_FILE}" "${GCFG_FLAG}")" || exit $?
    # ... remove flag
    if [ -n "${GCFG_FLAG}" ]; then
      [ ! -e "${GCFG_FILE_FLAG}" ] && exit 0
      rm -f "${GCFG_FILE_FLAG}"
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${GCFG_FILE_FLAG}" && exit 1
    else
      _gcfg_confirm "${GCFG_ACTION}" 'Are you sure you want to remove all flags ?'
      [ "$(_gcfg_answer 'y/n')" == 'n' ] && exit 0
      rm -f "${GCFG_FILE_FLAG}"\{*\}
      [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${GCFG_FILE_FLAG}{*}" && exit 1
    fi
    # ... cleanup directories
    _gcfg_rmdir "$(dirname "${GCFG_FILE}")"
    ;;

  'verify')
    # ... loop through files in configuration repository
    for GCFG_FILE in $(gcfg list); do
      GCFG_FILE_GIT="$(_gcfg_path_git "${GCFG_FILE}")" || continue
      GCFG_FILE_ORIG="$(_gcfg_path_original "${GCFG_FILE}")" || exit $?
      GCFG_FILE_FLAG="$(_gcfg_path_flag "${GCFG_FILE}")" || exit $?
      # ... check actual file
      repair=0
      if [ -e "${GCFG_FILE}" ]; then
        # ... file exists
        exists=1
        if [ -h "${GCFG_FILE}" ]; then
          if [ -z "$(ls -l "${GCFG_FILE}" | grep "\-> ${GCFG_FILE_GIT}$")" ]; then
            # ... invalid symlink
            repair=1
          fi
        else
          # ... not a symlink
          if [ "$(stat --printf='%h' "${GCFG_FILE}")" != '1' ]; then
            # ... hardlink
            # NOTE: we accept hardlinks to the configuration repository, for some programs choke on symlinks
            if [ "$(stat --printf='%i' "${GCFG_FILE}")" != "$(stat --printf='%i' "${GCFG_FILE_GIT}")" ]; then
              # ... different inodes
              repair=1
            fi
          else
            # ... regular file
            # NOTE: we accept regular files that don't differ from configuration repository, for some programs choke on symlinks AND hardlinks
            if [ -n "$(diff -q "${GCFG_FILE}" "${GCFG_FILE_GIT}")" ]; then
              repair=1
            fi
          fi
        fi
      else
        # ... file does not exist
        exists=0
        repair=1
      fi
      if [ ${repair} -ne 0 ]; then
        if [ ${exists} -ne 0 ]; then
          _gcfg_warning "${GCFG_ACTION}" "Actual file is different from configuration repository's version" "$(stat --printf='[%i] %N (%F; %h)\n' "${GCFG_FILE}")"
          _gcfg_confirm "${GCFG_ACTION}" 'Show [D]ifferences, use [A]ctual/[R]epository version, [P]urge or [S]kip ?'
        else
          _gcfg_warning "${GCFG_ACTION}" 'Actual file is missing' "${GCFG_FILE}"
          _gcfg_confirm "${GCFG_ACTION}" 'Use [R]epository version, [P]urge or [S]kip ?'
        fi
        while true; do
          if [ ${exists} -ne 0 ]; then
            answer="$(_gcfg_answer 'd/a/r/p/s')"
          else
            answer="$(_gcfg_answer 'r/p/s')"
          fi
          case "${answer}" in
            'd')
              # ... show differences between files
              diff -uN "${GCFG_FILE_GIT}" "${GCFG_FILE}" | less
              continue
              ;;
            'a')
              _gcfg_confirm "${GCFG_ACTION}" 'Use [H]ardlink, [S]ymlink or [C]opy ?'
              case "$(_gcfg_answer 'h/s/c' 'h')" in
                'h')
                  # ... replace configuration repository's file with actual version and hardlink it back
                  rm -f "${GCFG_FILE_GIT}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${GCFG_FILE_GIT}" && break
                  mv "${GCFG_FILE}" "${GCFG_FILE_GIT}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to move file' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && break
                  ln "${GCFG_FILE_GIT}" "${GCFG_FILE}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to hardlink file' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && break
                  ;;
                's')
                  # ... replace configuration repository's file with actual version and symlink it back
                  rm -f "${GCFG_FILE_GIT}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${GCFG_FILE_GIT}" && break
                  mv "${GCFG_FILE}" "${GCFG_FILE_GIT}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to move file' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && break
                  ln -s "${GCFG_FILE_GIT}" "${GCFG_FILE}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to symlink file' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && break
                  ;;
                'c')
                  # ... replace configuration repository's file content with actual version's
                  cat "${GCFG_FILE}" > "${GCFG_FILE_GIT}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to update file content' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && break
                  ;;
              esac
              break
              ;;
            'r')
              if [ ${exists} -ne 0 ]; then
                # ... backup original file
                _gcfg_confirm "${GCFG_ACTION}" 'Save/update the original backup file ?'
                if [ "$(_gcfg_answer 'y/n')" == 'y' ]; then
                  GCFG_FILE_ORIG_DIR="$(dirname "${GCFG_FILE_ORIG}")"
                  [ ! -e "${GCFG_FILE_ORIG_DIR}" ] && mkdir -p "${GCFG_FILE_ORIG_DIR}"
                  [ ! -d "${GCFG_FILE_ORIG_DIR}" ] && _gcfg_error "${GCFG_ACTION}" 'Failed to create directory' "${GCFG_FILE_ORIG_DIR}" && break
                  cp -p "${GCFG_FILE}" "${GCFG_FILE_ORIG}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to copy file' "${GCFG_FILE} -> ${GCFG_FILE_ORIG}" && break
                fi
                # ... remove actual file
                rm -f "${GCFG_FILE}"
                [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${GCFG_FILE}" && break
              fi
              _gcfg_confirm "${GCFG_ACTION}" 'Use [H]ardlink, [S]ymlink or [C]opy ?'
              case "$(_gcfg_answer 'h/s/c' 'h')" in
                'h')
                  # ... create hardlink to the configuration repository's file
                  ln "${GCFG_FILE_GIT}" "${GCFG_FILE}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to hardlink file' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && break
                  break
                  ;;
                's')
                  # ... create symlink to the configuration repository's file
                  ln -s "${GCFG_FILE_GIT}" "${GCFG_FILE}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to symlink file' "${GCFG_FILE} -> ${GCFG_FILE_GIT}" && break
                  break
                  ;;
                'c')
                  # ... copy configuration repository's file back
                  cp -p "${GCFG_FILE_GIT}" "${GCFG_FILE}"
                  [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to copy file' "${GCFG_FILE_GIT} -> ${GCFG_FILE}" && break
                  break
                  ;;
              esac
              ;;
            'p')
              # ... remove file from GIT
              late_exit=0
              _gcfg_pushd || exit $?
              git rm --force "${GCFG_FILE##/}"
              [ $? -ne 0 ] && late_exit=$? && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${GCFG_FILE_GIT}"
              _gcfg_popd || exit $?
              [ ${late_exit} -ne 0 ] && unset late_exit && break
              unset late_exit
              # ... remove file flags
              for flag in "${GCFG_FILE_FLAG}"\{*\}; do
                rm -f "${flag}"
                [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${flag}" && break
              done
              # ... remove original backup file
              if [ -e "${GCFG_FILE_ORIG}" ]; then
                rm -f "${GCFG_FILE_ORIG}"
                [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to remove file' "${GCFG_FILE_ORIG}" && break
              fi
              # ... cleanup directories
              _gcfg_rmdir "$(dirname "${GCFG_FILE}")"
              # ... done
              break
              ;;
            's')
              break
              ;;
          esac
        done
        unset answer
        unset exists
      fi
      unset repair
    done
    ;;

  'pkglist')
    # ... update installed packages list
    aptitude search --disable-columns --display-format '%p' --sort 'name' '?and(?installed,?not(?automatic))' > "${GCFG_REPO_PKGLIST}"
    [ $? -ne 0 ] && _gcfg_error "${GCFG_ACTION}" 'Failed to update installed packages list' "${GCFG_REPO_PKGLIST}" && exit 1
    _gcfg_info "${GCFG_ACTION}" 'Installed packages list successfully udpate' "cat '${GCFG_REPO_PKGLIST}' OR gcfg diff '${GCFG_REPO_PKGLIST}'"
    ;;

  'git')
    # ... verify
    gcfg verify
    # ... arguments
    [ $# -le 0 ] && _gcfg_error "${GCFG_ACTION}" 'Missing <git-command> parameter' && exit 1
    GCFG_GITCMD="${1}"; shift
    # ... GIT parameters
    case "${GCFG_GITCMD}" in
      'commit')
        GCFG_GITOPTS="--author '${GCFG_AUTHOR} <${GCFG_EMAIL}>'"
        ;;
    esac
    # ... GIT command
    _gcfg_pushd || exit $?
    eval git ${GCFG_GITCMD} ${GCFG_GITOPTS} $*
    _gcfg_popd || exit $?
    ;;

esac


## Exit
exit 0

